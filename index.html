<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bible Round Table – Realtime Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #e5e7eb;
      margin: 0;
      padding: 1rem;
    }
    h1 { margin-top: 0; }
    .panel {
      max-width: 1100px;
      margin: 0 auto;
      background: #020617;
      border-radius: 12px;
      border: 1px solid #334155;
      padding: 1rem 1.25rem;
      box-shadow: 0 20px 50px rgba(0,0,0,0.7);
    }
    input, button, select {
      font: inherit;
    }
    input[type="text"], select {
      padding: 0.4rem 0.5rem;
      border-radius: 999px;
      border: 1px solid #475569;
      background: #020617;
      color: #e5e7eb;
      width: 100%;
      max-width: 260px;
    }
    button {
      margin-top: 0.35rem;
      padding: 0.4rem 0.8rem;
      border-radius: 999px;
      border: none;
      background: #f97316;
      color: #020617;
      cursor: pointer;
      font-weight: 600;
    }
    button.secondary {
      background: #1e293b;
      color: #e5e7eb;
    }
    button.small {
      padding: 0.25rem 0.6rem;
      font-size: 0.8rem;
    }
    button.cardBtn {
      border-radius: 12px;
      padding: 0.55rem 0.75rem;
      background: #020617;
      border: 1px solid #475569;
      color: #e5e7eb;
      text-align: left;
      width: 100%;
      max-width: 260px;
      white-space: normal;
    }
    button.cardBtn.correct {
      border-color: #22c55e;
    }
    button.cardBtn.wrong {
      border-color: #f97316;
    }
    button.cardBtn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    .row {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 0.75rem;
    }
    .box {
      flex: 1 1 260px;
      border-radius: 10px;
      border: 1px solid #1f2937;
      padding: 0.75rem;
      background: #020617;
    }
    .label {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-bottom: 0.15rem;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      word-break: break-all;
    }
    .field {
      margin-bottom: 0.5rem;
    }
    .section-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    #log {
      font-size: 0.78rem;
      white-space: pre-wrap;
      max-height: 220px;
      overflow-y: auto;
      border-radius: 8px;
      border: 1px solid #1f2937;
      padding: 0.5rem;
      background: #020617;
    }
    #question, #verseRef, #verseText {
      margin: 0.15rem 0;
    }
    #playersList div {
      padding: 0.1rem 0;
      font-size: 0.85rem;
    }
    #adminControls {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px dashed #1f2937;
      display: none;
    }
    #adminVotesList div {
      padding: 0.1rem 0;
      font-size: 0.8rem;
      color: #cbd5f5;
    }
    #gameControls {
      margin-top: 0.75rem;
      padding-top: 0.5rem;
      border-top: 1px dashed #1f2937;
      display: none;
    }
    #cardsContainer {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 0.4rem;
    }
    #roundTimer {
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="panel">
    <h1>Bible Round Table – Realtime Test</h1>
    <p style="font-size:0.9rem;color:#9ca3af">
      This page tests: Google Sheets → Apps Script → Firebase → multiplayer.
      <br>Use one browser to <strong>Create Game</strong>, then others to <strong>Join</strong> with the same Game ID.
    </p>

    <div class="row">
      <div class="box">
        <div class="section-title">1. Player Info</div>
        <div class="field">
          <div class="label">First name (max 15 chars)</div>
          <input type="text" id="firstName" maxlength="15" placeholder="e.g. John">
        </div>
        <div class="field">
          <div class="label">Last name (max 15 chars)</div>
          <input type="text" id="lastName" maxlength="15" placeholder="e.g. Kim">
        </div>
      </div>

      <div class="box">
        <div class="section-title">2. Create Game (become initial Admin)</div>
        <div class="field">
          <div class="label">Sheets API URL (Apps Script Web App)</div>
          <input type="text" id="scriptUrl" placeholder="https://script.google.com/macros/s/XXX/exec">
        </div>
        <button id="btnCreate">Create Game</button>
        <div class="field" style="margin-top:0.5rem">
          <div class="label">Created Game ID</div>
          <div class="mono" id="createdGameId">–</div>
        </div>
      </div>

      <div class="box">
        <div class="section-title">3. Join Existing Game</div>
        <div class="field">
          <div class="label">Game ID</div>
          <input type="text" id="joinGameId" placeholder="Paste Game ID">
        </div>
        <button class="secondary" id="btnJoin">Join Game</button>
        <div class="field" style="margin-top:0.5rem">
          <div class="label">Current Connection</div>
          <div class="mono" id="status">Not connected</div>
        </div>
      </div>
    </div>

    <hr style="margin:1rem 0;border:0;border-top:1px solid #1f2937;">

    <div class="row">
      <div class="box">
        <div class="section-title">Shared Game State</div>
        <div class="label">Game ID</div>
        <div class="mono" id="currentGameId">–</div>

        <div class="label" style="margin-top:0.2rem">Game status</div>
        <div id="gameStatus">Lobby</div>

        <div class="label" style="margin-top:0.2rem">Round</div>
        <div id="roundInfo">–</div>

        <div class="label" style="margin-top:0.2rem">Mode</div>
        <div id="roundMode">–</div>

        <div class="label" style="margin-top:0.2rem">Timer (visual only for now)</div>
        <div id="roundTimer">–</div>

        <div class="label" style="margin-top:0.3rem">Current admin</div>
        <div id="currentAdmin">–</div>

        <div class="label" style="margin-top:0.4rem">Verse reference</div>
        <div id="verseRef">–</div>

        <div class="label" style="margin-top:0.4rem">Verse text</div>
        <div id="verseText">–</div>

        <div class="label" style="margin-top:0.4rem">Question</div>
        <div id="question">–</div>
      </div>

      <div class="box">
        <div class="section-title">Players in this game</div>
        <div class="label">You</div>
        <div class="mono" id="youName">–</div>
        <div class="mono" id="youId" style="font-size:0.75rem;color:#9ca3af;">–</div>

        <div class="label" style="margin-top:0.5rem">All players</div>
        <div id="playersList" style="font-size:0.85rem;color:#e5e7eb;">
          (none yet)
        </div>

        <div id="adminVoting" style="margin-top:0.75rem;">
          <div class="section-title" style="font-size:0.85rem;">Admin voting</div>
          <div class="field">
            <div class="label">Vote for admin</div>
            <select id="adminVoteSelect">
              <option value="">-- choose player --</option>
            </select>
            <button class="small secondary" id="btnVoteAdmin">Submit vote</button>
          </div>
          <div class="field">
            <div class="label">Current votes</div>
            <div id="adminVotesList">(no votes yet)</div>
          </div>
          <div id="adminControls">
            <div class="label">Admin controls</div>
            <button class="small" id="btnApplyAdmin">Apply admin by votes</button>
            <div style="font-size:0.75rem;color:#9ca3af;margin-top:0.25rem;">
              (You are admin – this will set the player with the most votes as new admin.)
            </div>
          </div>
        </div>

        <div id="gameControls">
          <div class="section-title" style="font-size:0.85rem;">Game setup (admin only)</div>
          <div class="field">
            <div class="label">Rounds</div>
            <select id="roundsMode">
              <option value="3">3 rounds</option>
              <option value="5">5 rounds</option>
              <option value="10">10 rounds</option>
              <option value="all">All questions</option>
            </select>
          </div>
          <div class="field">
            <button class="small" id="btnStartGame">Start game</button>
            <button class="small secondary" id="btnNextRound">Next round</button>
            <button class="small secondary" id="btnEndGame">End game</button>
          </div>
          <div style="font-size:0.75rem;color:#9ca3af;" id="gameHint">
            Status: waiting in lobby. Choose rounds and click "Start game".
          </div>
        </div>
      </div>

      <div class="box">
        <div class="section-title">Debug Log</div>
        <div id="log"></div>
      </div>
    </div>

    <div class="row" style="margin-top:1rem;">
      <div class="box">
        <div class="section-title">Your answer cards (this round)</div>
        <div class="label">Click one card to answer. Wrong answers apply penalties.</div>
        <div id="cardsContainer">
          (waiting for game to start)
        </div>
        <div class="label" style="margin-top:0.5rem">Round feedback</div>
        <div id="roundFeedback">–</div>
      </div>
      <div class="box">
        <div class="section-title">Round notes</div>
        <p style="font-size:0.8rem;color:#9ca3af;">
          • First correct answer: +10 pts<br>
          • 2nd: +5 pts, 3rd: +3 pts<br>
          • 4th–5th: +1 pt, 6+ : 0 pts<br>
          • Wrong answers: −1, then −2, then −4, etc. per round (doubles each time).
        </p>
      </div>
    </div>
  </div>

  <!-- Firebase + app logic -->
  <script type="module">
    /************************************************
     * 1) Firebase setup – USE YOUR CONFIG HERE
     ************************************************/
    const firebaseConfig = {
      apiKey: "AIzaSyAvowntn96MSlL3Stxqh-gUUGEpAnJT6uo",
      authDomain: "christian-roundtable.firebaseapp.com",
      projectId: "christian-roundtable",
      storageBucket: "christian-roundtable.firebasestorage.app",
      messagingSenderId: "981074913898",
      appId: "1:981074913898:web:52183899c18e5cd0aff813",
      measurementId: "G-JT29F5HZGE"
    };

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import {
      getFirestore,
      collection,
      doc,
      addDoc,
      setDoc,
      getDoc,
      onSnapshot,
      serverTimestamp,
      increment
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    /************************************************
     * 2) Helpers & state
     ************************************************/
    function log(msg) {
      const el = document.getElementById('log');
      el.textContent += msg + "\\n";
      el.scrollTop = el.scrollHeight;
    }

    function getPlayerName() {
      let f = document.getElementById('firstName').value.trim() || "Anon";
      let l = document.getElementById('lastName').value.trim() || "Player";
      f = f.slice(0, 15);
      l = l.slice(0, 15);
      return { firstName: f, lastName: l };
    }

    function makePlayerId(firstName, lastName) {
      const raw = (firstName + "_" + lastName).toLowerCase();
      return raw.replace(/[^a-z0-9_]/g, "").slice(0, 30) || "player_" + Math.random().toString(36).slice(2, 10);
    }

    function getPointsForPlace(place) {
      if (place === 1) return 10;
      if (place === 2) return 5;
      if (place === 3) return 3;
      if (place === 4 || place === 5) return 1;
      return 0;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function extractOptionsFromQuestion(q) {
      const correct =
        q.correctAnswer || q.CorrectAnswer || q.correct || q.answer || "";
      const elseAns =
        q.ElseAnswer || q.elseAnswer || null;
      const wrongs = [];
      const keys = [
        "Wrong1","Wrong2","Wrong3","Wrong4","Wrong5",
        "Wrong6","Wrong7","Wrong8","Wrong9",
        "wrong1","wrong2","wrong3","wrong4","wrong5",
        "wrong6","wrong7","wrong8","wrong9"
      ];
      keys.forEach(k => {
        if (q[k]) wrongs.push(q[k]);
      });
      return { correct, elseAns, wrongs };
    }

    function buildCardsForPlayer(correct, elseAns, wrongs) {
      const safeWrongs = (wrongs || []).filter(x => !!x);
      if (!correct && !elseAns && safeWrongs.length === 0) {
        return { cards: [], correctIndex: -1 };
      }

      let useElse = false;
      if (elseAns) {
        useElse = Math.random() < 0.5; // sometimes require "Answer is not here"
      }

      let correctText;
      let wrongCandidates;

      if (useElse && elseAns) {
        correctText = elseAns;
        wrongCandidates = safeWrongs
          .concat(correct ? [correct] : [])
          .filter(v => v !== correctText && v !== correct);
      } else {
        correctText = correct || elseAns || safeWrongs[0];
        wrongCandidates = safeWrongs
          .concat(elseAns ? [elseAns] : [])
          .filter(v => v !== correctText);
      }

      if (wrongCandidates.length === 0) {
        wrongCandidates = safeWrongs.slice();
      }

      shuffle(wrongCandidates);
      const wrongsPicked = wrongCandidates.slice(0, 3);
      const all = [correctText, ...wrongsPicked];
      shuffle(all);
      const correctIndex = all.indexOf(correctText);
      return { cards: all, correctIndex };
    }

    let currentGameId = null;
    let currentPlayerId = null;
    let currentPlayerDisplayName = null;
    let currentIsAdmin = false;
    let currentRoundNumber = 0;

    let unsubscribeGame = null;
    let unsubscribePlayers = null;
    let latestPlayersSnapshot = null;

    let unsubscribeMyRound = null;
    let unsubscribeRoundAdmin = null;
    let myRoundState = null;

    const adminControlsEl = document.getElementById('adminControls');
    const adminVoteSelect = document.getElementById('adminVoteSelect');
    const adminVotesListEl = document.getElementById('adminVotesList');

    const gameControlsEl = document.getElementById('gameControls');
    const gameStatusEl = document.getElementById('gameStatus');
    const roundInfoEl = document.getElementById('roundInfo');
    const roundModeEl = document.getElementById('roundMode');
    const gameHintEl = document.getElementById('gameHint');
    const roundsModeSelect = document.getElementById('roundsMode');
    const btnStartGame = document.getElementById('btnStartGame');
    const btnNextRound = document.getElementById('btnNextRound');
    const btnEndGame = document.getElementById('btnEndGame');
    const roundTimerEl = document.getElementById('roundTimer');
    const cardsContainer = document.getElementById('cardsContainer');
    const roundFeedbackEl = document.getElementById('roundFeedback');

    let timerInterval = null;

    /************************************************
     * 3) Player registration
     ************************************************/
    async function registerPlayer(gameId, isAdminInitial) {
      const { firstName, lastName } = getPlayerName();
      const displayName = (firstName + " " + lastName).trim();
      const playerId = makePlayerId(firstName, lastName);

      const playersCol = collection(db, "games", gameId, "players");
      const playerRef = doc(playersCol, playerId);

      await setDoc(playerRef, {
        firstName,
        lastName,
        displayName,
        isAdmin: !!isAdminInitial,
        joinedAt: serverTimestamp(),
        score: 0,
        totalWrongPenalty: 0,
        totalCorrectTimeMs: 0
      }, { merge: true });

      currentPlayerId = playerId;
      currentPlayerDisplayName = displayName;

      log("Registered player " + displayName + " with ID " + playerId + (isAdminInitial ? " [admin]" : ""));
    }

    /************************************************
     * 4) Create game – fetch questions, set admin
     ************************************************/
    async function handleCreate() {
      const scriptUrl = document.getElementById('scriptUrl').value.trim();
      if (!scriptUrl) {
        alert("Enter your Apps Script Web App URL first.");
        return;
      }

      const { firstName, lastName } = getPlayerName();
      const adminDisplayName = (firstName + " " + lastName).trim();
      const adminPlayerId = makePlayerId(firstName, lastName);

      log("Creating game as " + adminDisplayName + "...");

      try {
        const res = await fetch(scriptUrl + "?action=getQuestions");
        if (!res.ok) throw new Error("HTTP " + res.status);
        const questions = await res.json();
        log("Loaded " + questions.length + " questions from Sheets.");

        if (!Array.isArray(questions) || questions.length === 0) {
          alert("No questions returned from Sheets.");
          return;
        }

        const gamesCol = collection(db, "games");
        const gameDoc = await addDoc(gamesCol, {
          createdAt: serverTimestamp(),
          status: "lobby",
          roundsMode: "3",
          totalRounds: 3,
          currentRound: 0,
          adminDisplayName,
          adminPlayerId,
          currentQuestionIndex: 0,
          questions
        });

        const gameId = gameDoc.id;
        currentGameId = gameId;

        document.getElementById('createdGameId').textContent = gameId;
        document.getElementById('joinGameId').value = gameId;
        document.getElementById('status').textContent = "Created game " + gameId;
        document.getElementById('currentGameId').textContent = gameId;
        document.getElementById('currentAdmin').textContent = adminDisplayName;

        await registerPlayer(gameId, true);

        subscribeToGame(gameId);
        subscribeToPlayers(gameId);
      } catch (err) {
        console.error(err);
        log("Error creating game: " + err.message);
        alert("Error creating game; see log.");
      }
    }

    /************************************************
     * 5) Join existing game – register as player
     ************************************************/
    async function handleJoin() {
      const gameId = document.getElementById('joinGameId').value.trim();
      if (!gameId) {
        alert("Enter a Game ID to join.");
        return;
      }

      try {
        const gameRef = doc(db, "games", gameId);
        const snap = await getDoc(gameRef);
        if (!snap.exists()) {
          alert("Game not found. Check the Game ID.");
          return;
        }

        const data = snap.data();
        document.getElementById('currentAdmin').textContent = data.adminDisplayName || "–";

        currentGameId = gameId;
        document.getElementById('currentGameId').textContent = gameId;
        document.getElementById('status').textContent = "Joining game " + gameId + "...";

        await registerPlayer(gameId, false);

        subscribeToGame(gameId);
        subscribeToPlayers(gameId);
      } catch (err) {
        console.error(err);
        log("Error joining game: " + err.message);
        alert("Error joining game; see log.");
      }
    }

    /************************************************
     * 6) Subscribe to game doc
     ************************************************/
    function subscribeToGame(gameId) {
      if (unsubscribeGame) {
        unsubscribeGame();
        unsubscribeGame = null;
      }
      const gameRef = doc(db, "games", gameId);

      unsubscribeGame = onSnapshot(gameRef, (snap) => {
        if (!snap.exists()) {
          document.getElementById('status').textContent = "Game not found.";
          log("Game " + gameId + " does not exist.");
          return;
        }
        const data = snap.data();
        document.getElementById('status').textContent = "Connected to game " + gameId;

        const adminName = data.adminDisplayName || "–";
        document.getElementById('currentAdmin').textContent = adminName;

        const status = data.status || "lobby";
        gameStatusEl.textContent = status === "in_progress" ? "In progress" :
                                   status === "finished" ? "Finished" : "Lobby";

        const roundsMode = data.roundsMode || "3";
        roundModeEl.textContent = roundsMode === "all" ? "All questions" : roundsMode + " rounds";

        const totalRounds = data.totalRounds || 0;
        const currentRound = data.currentRound || 0;
        currentRoundNumber = currentRound;

        if (status === "in_progress") {
          roundInfoEl.textContent = "Round " + currentRound + " of " + totalRounds;
        } else if (status === "finished") {
          roundInfoEl.textContent = "Game finished (" + totalRounds + " rounds)";
        } else {
          roundInfoEl.textContent = "Not started";
        }

        const idx = data.currentQuestionIndex || 0;
        const qList = data.questions || [];
        const q = qList[idx] || null;

        if (q) {
          document.getElementById('verseRef').textContent = q.verseRef || q.VerseRef || "–";
          document.getElementById('verseText').textContent = q.verseText || q.VerseText || "–";
          document.getElementById('question').textContent = q.question || q.Question || "–";
          log("Showing question #" + (idx + 1) + " (" + (q.id || "no id") + ")");
        } else {
          document.getElementById('verseRef').textContent = "–";
          document.getElementById('verseText').textContent = "–";
          document.getElementById('question').textContent = "No question at this index.";
          log("No question at index " + idx);
        }

        if (data.adminPlayerId && currentPlayerId) {
          currentIsAdmin = (data.adminPlayerId === currentPlayerId);
          adminControlsEl.style.display = currentIsAdmin ? "block" : "none";
          gameControlsEl.style.display = currentIsAdmin ? "block" : "none";

          const youNameEl = document.getElementById('youName');
          if (currentPlayerDisplayName) {
            youNameEl.textContent = currentPlayerDisplayName + (currentIsAdmin ? " (admin)" : "");
          }
        }

        if (currentIsAdmin) {
          roundsModeSelect.value = roundsMode;
          if (status === "lobby") {
            btnStartGame.disabled = false;
            btnNextRound.disabled = true;
            btnEndGame.disabled = true;
            gameHintEl.textContent = "Status: lobby. Choose rounds and click 'Start game'.";
          } else if (status === "in_progress") {
            btnStartGame.disabled = true;
            btnEndGame.disabled = false;
            btnNextRound.disabled = currentRound >= totalRounds;
            gameHintEl.textContent = "Game in progress. Use 'Next round' to advance or 'End game' to finish.";
          } else {
            btnStartGame.disabled = true;
            btnNextRound.disabled = true;
            btnEndGame.disabled = true;
            gameHintEl.textContent = "Game finished.";
          }
        }

        // Timer (visual, simple 30s countdown reset per round)
        if (status === "in_progress" && currentRound > 0) {
          startVisualTimer();
        } else {
          stopVisualTimer();
        }

        // subscribe to my round state + admin scoring
        if (status === "in_progress" && currentRound > 0) {
          if (currentGameId && currentPlayerId) {
            subscribeToMyRoundState(currentGameId, currentRound);
          }
          if (currentIsAdmin && currentGameId) {
            subscribeRoundForAdminScoring(currentGameId, currentRound);
          }
        } else {
          if (unsubscribeMyRound) { unsubscribeMyRound(); unsubscribeMyRound = null; }
          if (unsubscribeRoundAdmin) { unsubscribeRoundAdmin(); unsubscribeRoundAdmin = null; }
        }
      }, (err) => {
        console.error(err);
        document.getElementById('status').textContent = "Error listening to game.";
        log("onSnapshot (game) error: " + err.message);
      });
    }

    /************************************************
     * 7) Subscribe to players collection
     ************************************************/
    function subscribeToPlayers(gameId) {
      if (unsubscribePlayers) {
        unsubscribePlayers();
        unsubscribePlayers = null;
      }
      const playersCol = collection(db, "games", gameId, "players");

      unsubscribePlayers = onSnapshot(playersCol, (snap) => {
        latestPlayersSnapshot = snap;

        const listEl = document.getElementById('playersList');
        const youNameEl = document.getElementById('youName');
        const youIdEl = document.getElementById('youId');

        if (snap.empty) {
          listEl.textContent = "(no players yet)";
          return;
        }

        let html = "";
        let isYouAdmin = false;
        const options = [];

        snap.forEach((docSnap) => {
          const p = docSnap.data();
          const pid = docSnap.id;
          const name = (p.displayName || (p.firstName + " " + p.lastName) || "Unnamed").trim();
          const isYou = (pid === currentPlayerId);
          const isAdmin = !!p.isAdmin;
          const score = typeof p.score === "number" ? p.score : 0;

          if (isYou && isAdmin) isYouAdmin = true;

          html += `<div>${name} – ${score} pts${isYou ? " (you)" : ""}${isAdmin ? " ⭐" : ""}</div>`;
          options.push({ id: pid, name });
        });

        listEl.innerHTML = html;

        if (currentPlayerDisplayName) {
          youNameEl.textContent = currentPlayerDisplayName + (isYouAdmin ? " (admin)" : "");
          youIdEl.textContent = "Player ID: " + (currentPlayerId || "unknown");
        }

        currentIsAdmin = isYouAdmin;
        adminControlsEl.style.display = currentIsAdmin ? "block" : "none";
        gameControlsEl.style.display = currentIsAdmin ? "block" : "none";

        adminVoteSelect.innerHTML = '<option value="">-- choose player --</option>';
        options.forEach((opt) => {
          const o = document.createElement('option');
          o.value = opt.id;
          o.textContent = opt.name;
          adminVoteSelect.appendChild(o);
        });

        renderAdminVotes();
      }, (err) => {
        console.error(err);
        log("onSnapshot (players) error: " + err.message);
      });
    }

    /************************************************
     * 8) Admin voting – write vote
     ************************************************/
    async function handleVoteAdmin() {
      if (!currentGameId || !currentPlayerId) {
        alert("Join or create a game first.");
        return;
      }
      const chosenId = adminVoteSelect.value;
      if (!chosenId) {
        alert("Choose a player to vote for.");
        return;
      }

      try {
        const playerRef = doc(db, "games", currentGameId, "players", currentPlayerId);
        await setDoc(playerRef, {
          adminVoteFor: chosenId
        }, { merge: true });

        log("You voted for admin: " + chosenId);
      } catch (err) {
        console.error(err);
        log("Error submitting vote: " + err.message);
        alert("Error submitting vote; see log.");
      }
    }

    /************************************************
     * 9) Render admin votes
     ************************************************/
    function renderAdminVotes() {
      if (!latestPlayersSnapshot || latestPlayersSnapshot.empty) {
        adminVotesListEl.textContent = "(no votes yet)";
        return;
      }

      const players = {};
      const voteCounts = {};

      latestPlayersSnapshot.forEach((docSnap) => {
        const pid = docSnap.id;
        const p = docSnap.data();
        const name = (p.displayName || (p.firstName + " " + p.lastName) || "Unnamed").trim();
        players[pid] = name;

        if (p.adminVoteFor) {
          const cid = p.adminVoteFor;
          voteCounts[cid] = (voteCounts[cid] || 0) + 1;
        }
      });

      if (Object.keys(voteCounts).length === 0) {
        adminVotesListEl.textContent = "(no votes yet)";
        return;
      }

      let html = "";
      Object.keys(voteCounts).forEach((pid) => {
        const count = voteCounts[pid];
        const name = players[pid] || pid;
        html += `<div>${name}: ${count} vote(s)</div>`;
      });

      adminVotesListEl.innerHTML = html;
    }

    /************************************************
     * 10) Apply admin by votes (admin only)
     ************************************************/
    async function handleApplyAdmin() {
      if (!currentIsAdmin) {
        alert("Only the current admin can apply votes.");
        return;
      }
      if (!currentGameId || !latestPlayersSnapshot) {
        alert("No game or players loaded.");
        return;
      }

      const players = {};
      const voteCounts = {};

      latestPlayersSnapshot.forEach((docSnap) => {
        const pid = docSnap.id;
        const p = docSnap.data();
        const name = (p.displayName || (p.firstName + " " + p.lastName) || "Unnamed").trim();
        players[pid] = { name };

        if (p.adminVoteFor) {
          const cid = p.adminVoteFor;
          voteCounts[cid] = (voteCounts[cid] || 0) + 1;
        }
      });

      if (Object.keys(voteCounts).length === 0) {
        alert("No votes have been cast yet.");
        return;
      }

      let winnerId = null;
      let maxVotes = 0;
      Object.keys(voteCounts).forEach((pid) => {
        const count = voteCounts[pid];
        if (count > maxVotes) {
          maxVotes = count;
          winnerId = pid;
        }
      });

      const tied = Object.values(voteCounts).filter(v => v === maxVotes).length;
      if (tied > 1) {
        alert("There is a tie in votes. Resolve tie first.");
        return;
      }

      const winnerName = (players[winnerId] && players[winnerId].name) || winnerId;

      if (!confirm("Set new admin to: " + winnerName + " (" + maxVotes + " vote(s))?")) {
        return;
      }

      try {
        const gameRef = doc(db, "games", currentGameId);
        await setDoc(gameRef, {
          adminPlayerId: winnerId,
          adminDisplayName: winnerName
        }, { merge: true });

        const batchPromises = [];
        latestPlayersSnapshot.forEach((docSnap) => {
          const pid = docSnap.id;
          const pref = doc(db, "games", currentGameId, "players", pid);
          batchPromises.push(setDoc(pref, {
            isAdmin: pid === winnerId
          }, { merge: true }));
        });

        await Promise.all(batchPromises);

        log("Admin changed to " + winnerName + " by votes.");
      } catch (err) {
        console.error(err);
        log("Error applying admin: " + err.message);
        alert("Error applying admin; see log.");
      }
    }

    /************************************************
     * 11) Game controls (admin) – start / next / end
     ************************************************/
    async function generateCardsForAllPlayers(gameId, roundNumber, question) {
      if (!latestPlayersSnapshot || latestPlayersSnapshot.empty) return;
      const { correct, elseAns, wrongs } = extractOptionsFromQuestion(question || {});
      const promises = [];

      latestPlayersSnapshot.forEach((docSnap) => {
        const pid = docSnap.id;
        const { cards, correctIndex } = buildCardsForPlayer(correct, elseAns, wrongs);
        const psRef = doc(db, "games", gameId, "rounds", String(roundNumber), "playerStates", pid);
        promises.push(setDoc(psRef, {
          cards,
          correctIndex,
          hasAnswered: false,
          isCorrect: false,
          answerIndex: null,
          answerTimeMs: null,
          wrongCount: 0,
          pointsAwarded: null
        }, { merge: true }));
      });

      await Promise.all(promises);
      log("Generated cards for round " + roundNumber + " for " + latestPlayersSnapshot.size + " player(s).");
    }

    async function handleStartGame() {
      if (!currentIsAdmin || !currentGameId) {
        alert("Only the admin can start the game.");
        return;
      }
      try {
        const gameRef = doc(db, "games", currentGameId);
        const snap = await getDoc(gameRef);
        if (!snap.exists()) return;
        const data = snap.data();
        const questions = data.questions || [];
        const totalQ = questions.length;

        let mode = roundsModeSelect.value || "3";
        let totalRounds;
        if (mode === "all") {
          totalRounds = totalQ;
        } else {
          totalRounds = parseInt(mode, 10) || 3;
          if (totalRounds > totalQ) totalRounds = totalQ;
        }

        await setDoc(gameRef, {
          status: "in_progress",
          roundsMode: mode,
          totalRounds,
          currentRound: 1,
          currentQuestionIndex: 0
        }, { merge: true });

        await generateCardsForAllPlayers(currentGameId, 1, questions[0]);

        log("Game started with " + totalRounds + " rounds (mode=" + mode + ").");
      } catch (err) {
        console.error(err);
        log("Error starting game: " + err.message);
        alert("Error starting game; see log.");
      }
    }

    async function handleNextRound() {
      if (!currentIsAdmin || !currentGameId) {
        alert("Only the admin can advance rounds.");
        return;
      }
      try {
        const gameRef = doc(db, "games", currentGameId);
        const snap = await getDoc(gameRef);
        if (!snap.exists()) return;
        const data = snap.data();
        const questions = data.questions || [];
        const totalQ = questions.length;

        let currentRound = data.currentRound || 1;
        let totalRounds = data.totalRounds || 1;
        let idx = data.currentQuestionIndex || 0;

        if (currentRound >= totalRounds) {
          alert("Already at last round.");
          return;
        }

        currentRound += 1;
        idx = Math.min(idx + 1, totalQ - 1);

        await setDoc(gameRef, {
          currentRound,
          currentQuestionIndex: idx
        }, { merge: true });

        await generateCardsForAllPlayers(currentGameId, currentRound, questions[idx]);

        log("Moved to round " + currentRound + ".");
      } catch (err) {
        console.error(err);
        log("Error moving to next round: " + err.message);
        alert("Error moving to next round; see log.");
      }
    }

    async function handleEndGame() {
      if (!currentIsAdmin || !currentGameId) {
        alert("Only the admin can end the game.");
        return;
      }
      try {
        const gameRef = doc(db, "games", currentGameId);
        await setDoc(gameRef, {
          status: "finished"
        }, { merge: true });

        log("Game marked as finished.");
      } catch (err) {
        console.error(err);
        log("Error ending game: " + err.message);
        alert("Error ending game; see log.");
      }
    }

    /************************************************
     * 12) My round state (cards, answers)
     ************************************************/
    function renderMyCards() {
      if (!myRoundState || !myRoundState.cards || myRoundState.cards.length === 0) {
        cardsContainer.innerHTML = "(waiting for round cards)";
        return;
      }
      const cards = myRoundState.cards;
      const hasAnswered = !!myRoundState.hasAnswered;
      const isCorrect = !!myRoundState.isCorrect;
      const answerIndex = myRoundState.answerIndex;
      const correctIndex = typeof myRoundState.correctIndex === "number"
        ? myRoundState.correctIndex
        : -1;

      let html = "";
      cards.forEach((text, i) => {
        let extraClass = "";
        if (hasAnswered) {
          if (i === correctIndex) extraClass = " correct";
          else if (i === answerIndex && !isCorrect) extraClass = " wrong";
        }
        const disabled = hasAnswered;
        html += `<button class="cardBtn small${extraClass}" onclick="handleCardClick(${i})" ${disabled ? "disabled" : ""}>${text}</button>`;
      });
      cardsContainer.innerHTML = html;

      if (!hasAnswered) {
        roundFeedbackEl.textContent = "Choose your answer.";
      } else if (isCorrect) {
        roundFeedbackEl.textContent = "Correct! Wait for others.";
      } else {
        roundFeedbackEl.textContent = "You already answered wrong this round.";
      }
    }

    function subscribeToMyRoundState(gameId, roundNumber) {
      if (!gameId || !roundNumber || !currentPlayerId) return;
      if (unsubscribeMyRound) {
        unsubscribeMyRound();
        unsubscribeMyRound = null;
      }
      const psRef = doc(db, "games", gameId, "rounds", String(roundNumber), "playerStates", currentPlayerId);
      unsubscribeMyRound = onSnapshot(psRef, (snap) => {
        if (!snap.exists()) {
          myRoundState = null;
          cardsContainer.innerHTML = "(waiting for round cards)";
          roundFeedbackEl.textContent = "Waiting for admin.";
          return;
        }
        myRoundState = snap.data();
        renderMyCards();
      }, (err) => {
        console.error(err);
        log("onSnapshot (my round) error: " + err.message);
      });
    }

    async function handleCardClick(index) {
      if (!currentGameId || !currentPlayerId || !currentRoundNumber) return;
      if (!myRoundState || !myRoundState.cards) return;

      const now = Date.now();
      const correctIndex = typeof myRoundState.correctIndex === "number"
        ? myRoundState.correctIndex
        : -1;
      const isCorrectChoice = (index === correctIndex);

      const psRef = doc(db, "games", currentGameId, "rounds", String(currentRoundNumber), "playerStates", currentPlayerId);
      const playerRef = doc(db, "games", currentGameId, "players", currentPlayerId);

      // Already answered correctly – ignore
      if (myRoundState.hasAnswered && myRoundState.isCorrect) {
        return;
      }

      try {
        if (isCorrectChoice) {
          // mark answered; admin client will award points by order
          await setDoc(psRef, {
            hasAnswered: true,
            isCorrect: true,
            answerIndex: index,
            answerTimeMs: now
          }, { merge: true });

          roundFeedbackEl.textContent = "Correct! (+points will be assigned based on speed)";
          log("Answered correctly at " + now + ".");
        } else {
          // wrong answer – apply penalty
          const prevWrong = myRoundState.wrongCount || 0;
          const newWrong = prevWrong + 1;
          const penalty = -Math.pow(2, newWrong - 1); // -1, -2, -4, ...

          await Promise.all([
            setDoc(psRef, {
              wrongCount: newWrong
            }, { merge: true }),
            setDoc(playerRef, {
              score: increment(penalty),
              totalWrongPenalty: increment(penalty)
            }, { merge: true })
          ]);

          roundFeedbackEl.textContent = "Wrong! Penalty " + penalty + " pts (wrong #" + newWrong + " this round).";
          log("Wrong answer, penalty " + penalty + ".");
        }
      } catch (err) {
        console.error(err);
        log("Error submitting answer: " + err.message);
      }
    }

    /************************************************
     * 13) Admin scoring subscription
     ************************************************/
    function subscribeRoundForAdminScoring(gameId, roundNumber) {
      if (!currentIsAdmin || !gameId || !roundNumber) return;
      if (unsubscribeRoundAdmin) {
        unsubscribeRoundAdmin();
        unsubscribeRoundAdmin = null;
      }
      const colRef = collection(db, "games", gameId, "rounds", String(roundNumber), "playerStates");
      unsubscribeRoundAdmin = onSnapshot(colRef, (snap) => {
        handleScoringSnapshot(gameId, roundNumber, snap).catch(err => {
          console.error(err);
          log("Error in scoring snapshot: " + err.message);
        });
      }, (err) => {
        console.error(err);
        log("onSnapshot (round scoring) error: " + err.message);
      });
    }

    async function handleScoringSnapshot(gameId, roundNumber, snap) {
      if (snap.empty) return;

      const correctStates = [];
      snap.forEach((docSnap) => {
        const data = docSnap.data();
        if (data.isCorrect && data.answerTimeMs && typeof data.answerTimeMs === "number") {
          correctStates.push({
            playerId: docSnap.id,
            data
          });
        }
      });

      if (correctStates.length === 0) return;

      correctStates.sort((a, b) => a.data.answerTimeMs - b.data.answerTimeMs);

      const awardPromises = [];

      let place = 1;
      for (const entry of correctStates) {
        const { playerId, data } = entry;
        if (typeof data.pointsAwarded === "number") {
          place++;
          continue; // already awarded
        }
        const points = getPointsForPlace(place);

        const psRef = doc(db, "games", gameId, "rounds", String(roundNumber), "playerStates", playerId);
        const playerRef = doc(db, "games", gameId, "players", playerId);

        awardPromises.push(
          setDoc(psRef, { pointsAwarded: points }, { merge: true }),
          setDoc(playerRef, { score: increment(points) }, { merge: true })
        );

        log("Awarding " + points + " pts to " + playerId + " (place " + place + ").");
        place++;
      }

      if (awardPromises.length > 0) {
        await Promise.all(awardPromises);
      }
    }

    /************************************************
     * 14) Visual round timer (client-side only)
     ************************************************/
    function startVisualTimer() {
      stopVisualTimer();
      let timeLeft = 30;
      roundTimerEl.textContent = timeLeft + "s";
      timerInterval = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          roundTimerEl.textContent = "Time up";
          stopVisualTimer();
        } else {
          roundTimerEl.textContent = timeLeft + "s";
        }
      }, 1000);
    }
    function stopVisualTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      // don't clear text; leave last state
    }

    /************************************************
     * 15) Wire up buttons + global click handler
     ************************************************/
    document.getElementById('btnCreate').addEventListener('click', handleCreate);
    document.getElementById('btnJoin').addEventListener('click', handleJoin);
    document.getElementById('btnVoteAdmin').addEventListener('click', handleVoteAdmin);
    document.getElementById('btnApplyAdmin').addEventListener('click', handleApplyAdmin);
    btnStartGame.addEventListener('click', handleStartGame);
    btnNextRound.addEventListener('click', handleNextRound);
    btnEndGame.addEventListener('click', handleEndGame);

    // expose handler so inline onclick can call it
    window.handleCardClick = handleCardClick;
  </script>
</body>
</html>
