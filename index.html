<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bible Round Table – Realtime Test (Host)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      --bg: #020617;
      --panel: #020617;
      --border: #1f2937;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #f97316;
      --accent-soft: rgba(249,115,22,0.15);
      --accent2: #22c55e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #0f172a 0, #020617 40%, #000 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
    }
    .shell {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0.75rem;
    }
    h1 {
      font-size: 1.2rem;
      margin: 0 0 0.4rem;
    }
    .small {
      font-size: 0.78rem;
      color: var(--muted);
    }
    .grid {
      display: grid;
      grid-template-columns: 1.3fr 1.2fr 1.2fr;
      gap: 0.75rem;
      margin-top: 0.75rem;
    }
    .panel {
      background: var(--panel);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 0.7rem;
      box-shadow: 0 18px 40px rgba(0,0,0,0.7);
      min-height: 0;
    }
    label {
      display: block;
      font-size: 0.75rem;
      color: var(--muted);
      margin-bottom: 0.12rem;
    }
    input[type="text"], select {
      width: 100%;
      padding: 0.35rem 0.6rem;
      border-radius: 999px;
      border: 1px solid #475569;
      background: #020617;
      color: var(--text);
      font: inherit;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.35rem 0.8rem;
      font: inherit;
      font-size: 0.8rem;
      cursor: pointer;
      background: var(--accent);
      color: #020617;
      font-weight: 600;
    }
    button.secondary {
      background: #111827;
      color: var(--text);
    }
    button.danger {
      background: #b91c1c;
      color: #fee2e2;
    }
    button:disabled {
      opacity: 0.55;
      cursor: default;
    }
    .vstack { display: flex; flex-direction: column; gap: 0.4rem; }
    .hstack { display: flex; gap: 0.4rem; align-items: center; }

    .sectionTitle {
      font-size: 0.82rem;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      border: 1px solid #334155;
      font-size: 0.75rem;
      background: #020617;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; }

    #debugLog {
      white-space: pre-wrap;
      font-size: 0.75rem;
      max-height: 260px;
      overflow-y: auto;
    }

    #hostChatList {
      font-size: 0.75rem;
      max-height: 180px;
      overflow-y: auto;
    }

    #hostChatList div {
      margin-bottom: 0.18rem;
    }

    .roomListHostItem {
      border-radius: 10px;
      border: 1px solid #111827;
      padding: 0.35rem 0.45rem;
      margin-bottom: 0.25rem;
      background: radial-gradient(circle at top, rgba(148,163,184,0.12), #020617 60%);
      font-size: 0.75rem;
    }

    .roomListHostItemTitle {
      font-weight: 600;
      font-size: 0.8rem;
    }

    .answerCardsHost button {
      width: 100%;
      text-align: left;
      background: #020617;
      border-radius: 12px;
      border: 1px solid #334155;
      padding: 0.4rem 0.6rem;
      margin-bottom: 0.25rem;
      font-size: 0.8rem;
      cursor: default;
    }

    .timerBlink {
      animation: blinkTimer 0.3s ease-out;
    }
    @keyframes blinkTimer {
      0% { transform: scale(1); color: var(--text); }
      50% { transform: scale(1.5); color: #fca5a5; }
      100% { transform: scale(1); color: var(--text); }
    }

    @media (max-width: 1050px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <h1>Bible Round Table – Realtime Test (Host)</h1>
    <div class="small">
      Host / admin control panel. Players join via
      <span class="mono">play.html</span>.
    </div>

    <!-- Top row: player info + create/join -->
    <div class="grid">
      <!-- Player info -->
      <div class="panel">
        <div class="sectionTitle">1. Player Info</div>
        <div class="vstack">
          <div>
            <label for="firstName">First name (max 15 chars)</label>
            <input id="firstName" type="text" maxlength="15" placeholder="e.g. David">
          </div>
          <div>
            <label for="lastName">Last name (max 15 chars)</label>
            <input id="lastName" type="text" maxlength="15" placeholder="e.g. Kim">
          </div>
          <div class="small">
            This name identifies you as a player / admin.
          </div>
        </div>
      </div>

      <!-- Create game -->
      <div class="panel">
        <div class="sectionTitle">2. Create Game (become initial Admin)</div>
        <div class="vstack">
          <div>
            <label for="sheetsApiUrl">
              Sheets API URL (Apps Script Web App)<br>
              <span class="small">(Leave default or type <span class="mono">1234</span> to use default)</span>
            </label>
            <input id="sheetsApiUrl" type="text" placeholder="Apps Script Web App URL">
          </div>
          <div class="hstack">
            <button id="createGameBtn">Create Game</button>
            <div class="small">
              Created Game ID:<br>
              <span class="mono" id="createdGameId">–</span>
            </div>
          </div>
          <div class="small">
            Questions are loaded from Google Sheets via the Apps Script URL, then stored in Firebase.
          </div>
        </div>
      </div>

      <!-- Join game -->
      <div class="panel">
        <div class="sectionTitle">3. Join Existing Game</div>
        <div class="vstack">
          <div>
            <label for="joinGameId">Game ID</label>
            <input id="joinGameId" type="text" placeholder="Paste Game ID">
          </div>
          <div class="hstack">
            <button id="joinGameBtn">Join Game</button>
            <div class="small">
              Current Connection:<br>
              <span class="mono" id="currentConnection">Not connected</span>
            </div>
          </div>
          <div class="small">
            Game IDs can be seen in the room list on <span class="mono">play.html</span> or here in the "Rooms" panel.
          </div>
        </div>
      </div>
    </div>

    <!-- Middle row: shared game state / players / debug -->
    <div class="grid" style="margin-top:0.75rem;">
      <!-- Shared game state -->
      <div class="panel">
        <div class="sectionTitle">Shared Game State</div>
        <div class="vstack small">
          <div>Game ID: <span class="mono" id="stateGameId">–</span></div>
          <div>Game status: <span id="stateStatus">–</span></div>
          <div>Round: <span id="stateRound">–</span></div>
          <div>Mode: <span id="stateMode">–</span></div>
          <div>Timer (visual only for now): <span id="stateTimer" class="mono">–</span></div>
          <div>Current admin: <span id="stateAdmin">–</span></div>
          <div style="margin-top:0.4rem;">
            <div class="small">Verse reference</div>
            <div class="mono" id="stateVerseRef">–</div>
          </div>
          <div>
            <div class="small">Verse text</div>
            <div id="stateVerseText" style="font-size:0.8rem; line-height:1.35;">–</div>
          </div>
          <div>
            <div class="small">Question</div>
            <div id="stateQuestion" style="font-size:0.8rem; line-height:1.35;">–</div>
          </div>
        </div>
      </div>

      <!-- Players + admin stuff -->
      <div class="panel">
        <div class="sectionTitle">Players in this game</div>
        <div id="playersPanelHost" style="margin-bottom:0.4rem;"></div>

        <!-- Admin voting -->
        <div style="border-top:1px solid #1f2937; margin-top:0.4rem; padding-top:0.4rem;">
          <div class="sectionTitle" style="font-size:0.8rem;">Admin voting</div>
          <div class="vstack">
            <div>
              <label for="adminVoteSelect">Vote for admin</label>
              <select id="adminVoteSelect">
                <option value="">-- choose player --</option>
              </select>
            </div>
            <div class="hstack">
              <button id="submitVoteBtn" class="secondary">Submit vote</button>
              <div class="small">Current votes: <span id="adminVotesSummary">–</span></div>
            </div>
          </div>
        </div>

        <!-- Admin controls -->
        <div style="border-top:1px solid #1f2937; margin-top:0.4rem; padding-top:0.4rem;">
          <div class="sectionTitle" style="font-size:0.8rem;">Admin controls</div>
          <div class="vstack">
            <button id="applyAdminVotesBtn" class="secondary">Apply admin by votes</button>
            <div class="small">
              (You are admin – this will set the player with the most votes as new admin.)
            </div>
          </div>
        </div>

        <!-- Game setup -->
        <div style="border-top:1px solid #1f2937; margin-top:0.4rem; padding-top:0.4rem;">
          <div class="sectionTitle" style="font-size:0.8rem;">Game setup (admin only)</div>
          <div class="vstack small">
            <div>
              <label for="roundsModeSelect">Rounds</label>
              <select id="roundsModeSelect">
                <option value="3">3 rounds</option>
                <option value="5">5 rounds</option>
                <option value="10">10 rounds</option>
                <option value="all">All questions</option>
              </select>
            </div>
            <div class="hstack" style="margin-top:0.3rem;">
              <button id="startGameBtn">Start game</button>
              <button id="nextRoundBtn" class="secondary">Next round</button>
              <button id="endGameBtn" class="secondary">End game</button>
            </div>
            <div class="hstack" style="margin-top:0.3rem;">
              <button id="deleteGameBtn" class="danger">Delete game</button>
              <span class="small">Marks room as deleted and hides it from lobby.</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Debug + chat + room list for host -->
      <div class="panel">
        <div class="sectionTitle">Debug Log</div>
        <div id="debugLog"></div>

        <div style="border-top:1px solid #1f2937; margin-top:0.4rem; padding-top:0.4rem;">
          <div class="sectionTitle" style="font-size:0.8rem;">Room chat (read-only)</div>
          <div id="hostChatList"
               style="margin-top:0.3rem;border-radius:12px;border:1px solid #1f2937;
                      padding:0.3rem 0.4rem;max-height:160px;overflow-y:auto;
                      font-size:0.75rem;background:#020617;">
          </div>
        </div>

        <div style="border-top:1px solid #1f2937; margin-top:0.4rem; padding-top:0.4rem;">
          <div class="sectionTitle" style="font-size:0.8rem;">Rooms (recent)</div>
          <div id="roomsHostList"
               style="margin-top:0.3rem;border-radius:12px;border:1px solid #1f2937;
                      padding:0.3rem 0.4rem;max-height:180px;overflow-y:auto;
                      font-size:0.75rem;background:#020617;">
          </div>
        </div>
      </div>
    </div>

    <!-- Bottom row: host view of cards + notes -->
    <div class="grid" style="margin-top:0.75rem;">
      <!-- Answer cards -->
      <div class="panel">
        <div class="sectionTitle">Your answer cards (this round)</div>
        <div class="small">
          Click one card to answer. Wrong answers apply penalties. (For host view only; real answering happens from play.html.)
        </div>
        <div class="answerCardsHost" id="answerCardsHost" style="margin-top:0.4rem;">
          <div class="small">Waiting for game to start.</div>
        </div>
        <div class="small" style="margin-top:0.3rem;" id="hostRoundFeedback">–</div>
      </div>

      <!-- Notes -->
      <div class="panel">
        <div class="sectionTitle">Round notes</div>
        <div class="small">
          • First correct answer: +10 pts<br>
          • 2nd–5th: +5, +3 pts<br>
          • 4th–5th, if any: +1 pt<br>
          • 6+ : 0 pts<br>
          • Wrong answers: -1, then -2, then -4, etc (per round, doubles each time).
        </div>
      </div>

      <!-- Spacer or future controls -->
      <div class="panel">
        <div class="sectionTitle">Tips</div>
        <div class="small">
          Use this page only as host/admin.<br><br>
          Players join via <span class="mono">play.html</span>, pick a room, and answer cards there in realtime.
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase / host logic -->
  <script type="module">
    /************ Firebase init ************/
    const firebaseConfig = {
      apiKey: "AIzaSyAvowntn96MSlL3Stxqh-gUUGEpAnJT6uo",
      authDomain: "christian-roundtable.firebaseapp.com",
      projectId: "christian-roundtable",
      storageBucket: "christian-roundtable.firebasestorage.app",
      messagingSenderId: "981074913898",
      appId: "1:981074913898:web:52183899c18e5cd0aff813",
      measurementId: "G-JT29F5HZGE"
    };

    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
    import {
      getFirestore,
      collection,
      doc,
      setDoc,
      addDoc,
      deleteDoc,
      getDoc,
      getDocs,
      onSnapshot,
      serverTimestamp,
      orderBy,
      limit,
      query
    } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    /************ State ************/
    let currentGameId = null;
    let currentPlayerId = null;
    let currentPlayerName = null;
    let currentIsAdmin = false;
    let latestPlayers = [];
    let questionsCache = [];
    let currentRoundsMode = "3";
    let currentRoundNumber = 0;
    let totalRounds = 0;
    let lastGameStatus = null;

    // listeners
    let unsubGame = null;
    let unsubPlayers = null;
    let unsubHostChat = null;
    let unsubRoomsHost = null;
    let unsubMyRound = null;

    // timer (visual only)
    let timerInterval = null;

    // Default Apps Script URL (replace with your real one once)
    const DEFAULT_SHEETS_API_URL =
      "https://script.google.com/macros/s/AKfycbzOy5BJ9VbqUlujW2Hg4BbJM6KNdeM_LMjq5EHtafPDPuJI34NAEmDzxgbkvrSHkiPp/exec";

    // Helper
    const $ = id => document.getElementById(id);

    function log(msg) {
      const el = $("debugLog");
      el.textContent += msg + "\\n";
      el.scrollTop = el.scrollHeight;
    }

    /************ Name / IDs ************/
    function getName() {
      let f = $("firstName").value.trim() || "Anon";
      let l = $("lastName").value.trim() || "Player";
      f = f.slice(0,15);
      l = l.slice(0,15);
      return { firstName: f, lastName: l };
    }

    function makePlayerId(firstName,lastName) {
      const raw = (firstName + "_" + lastName).toLowerCase();
      return raw.replace(/[^a-z0-9_]/g,"").slice(0,30) || "player_" + Math.random().toString(36).slice(2,9);
    }

    /************ Timer visual ************/
    function startTimerVisual() {
      stopTimerVisual();
      let t = 30;
      const el = $("stateTimer");
      el.textContent = t + "s";
      timerInterval = setInterval(() => {
        t--;
        if (t <= 0) {
          el.textContent = "Time up";
          stopTimerVisual();
        } else {
          el.textContent = t + "s";
        }
      }, 1000);
    }
    function stopTimerVisual() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    function blinkTimer() {
      const el = $("stateTimer");
      if (!el) return;
      el.classList.remove("timerBlink");
      void el.offsetWidth;
      el.classList.add("timerBlink");
    }

    /************ Load questions from Sheets (via Apps Script) ************/
    async function loadQuestionsFromSheets(apiUrl) {
      // NOTE: adjust this to match your existing Apps Script response format if needed.
      // This version assumes GET apiUrl returns JSON: { questions: [ { id, VerseRef, VerseText, Question, CorrectAnswer, ElseAnswer, Wrong1..Wrong9 } ] }
      const res = await fetch(apiUrl);
      if (!res.ok) throw new Error("Failed to fetch questions from Sheets.");
      const data = await res.json();
      if (!data || !Array.isArray(data.questions || data)) {
        throw new Error("Question payload is not in expected format.");
      }
      // Accept either {questions:[...]} or just [...]
      const questions = Array.isArray(data.questions) ? data.questions : data;
      return questions;
    }

    /************ Questions -> per-player cards ************/
    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function buildCardsForPlayer(q) {
      const correct = q.CorrectAnswer || q.correctAnswer || "";
      const elseAns = q.ElseAnswer || q.elseAnswer || "";
      const wrongs = [
        q.Wrong1, q.Wrong2, q.Wrong3, q.Wrong4,
        q.Wrong5, q.Wrong6, q.Wrong7, q.Wrong8, q.Wrong9
      ].filter(x => !!x);

      if (!correct && !elseAns && wrongs.length === 0) {
        return { cards: [], correctIndex: -1 };
      }

      let useElse = false;
      if (elseAns) useElse = Math.random() < 0.5;

      let correctText;
      let wrongCandidates;

      if (useElse && elseAns) {
        correctText = elseAns;
        wrongCandidates = wrongs
          .concat(correct ? [correct] : [])
          .filter(v => v && v !== correctText);
      } else {
        correctText = correct || elseAns || wrongs[0];
        wrongCandidates = wrongs
          .concat(elseAns ? [elseAns] : [])
          .filter(v => v && v !== correctText);
      }

      if (wrongCandidates.length === 0) wrongCandidates = wrongs.slice();

      const fallbackPool = ["I don't know","Not sure","None of these"];
      let i = 0;
      while (wrongCandidates.length < 3) {
        const fallback = fallbackPool[i % fallbackPool.length];
        if (!wrongCandidates.includes(fallback) && fallback !== correctText) {
          wrongCandidates.push(fallback);
        }
        i++;
      }

      shuffle(wrongCandidates);
      const wrongsPicked = wrongCandidates.slice(0,3);
      const all = [correctText, ...wrongsPicked];
      shuffle(all);
      const correctIndex = all.indexOf(correctText);
      return { cards: all, correctIndex };
    }

    /************ Game creation ************/
    async function createGame() {
      const { firstName,lastName } = getName();
      const displayName = (firstName + " " + lastName).trim();
      const playerId = makePlayerId(firstName,lastName);

      currentPlayerId = playerId;
      currentPlayerName = displayName;

      let url = $("sheetsApiUrl").value.trim();
      if (!url || url === "1234") url = DEFAULT_SHEETS_API_URL;
      localStorage.setItem("sheetsApiUrl", url);

      log("Creating game as " + displayName + "…");

      // Load questions from Sheets
      const questions = await loadQuestionsFromSheets(url);
      questionsCache = questions;
      log("Loaded " + questions.length + " questions from Sheets.");

      const roundsMode = $("roundsModeSelect").value || "3";
      currentRoundsMode = roundsMode;
      totalRounds = (roundsMode === "all") ? questions.length : Number(roundsMode);

      const gamesCol = collection(db,"games");
      const gameDocRef = await addDoc(gamesCol,{
        createdAt: serverTimestamp(),
        status: "lobby",
        roundsMode,
        currentRound: 0,
        totalRounds,
        currentQuestionIndex: 0,
        adminPlayerId: playerId,
        adminDisplayName: displayName,
        questions,
        isDeleted: false
      });

      const gameId = gameDocRef.id;
      currentGameId = gameId;
      $("createdGameId").textContent = gameId;
      $("stateGameId").textContent = gameId;
      $("joinGameId").value = gameId;
      $("currentConnection").textContent = "Connected to game " + gameId;

      // register admin player
      const pref = doc(db,"games",gameId,"players",playerId);
      await setDoc(pref,{
        firstName,lastName,displayName,
        isAdmin:true,
        score:0,
        joinedAt:serverTimestamp()
      }, { merge:true });

      log("Registered player " + displayName + " as admin.");

      subscribeGame(gameId);
      subscribePlayers(gameId);
      subscribeHostChat(gameId);
    }

    /************ Join existing game ************/
    async function joinGame() {
      const gameId = $("joinGameId").value.trim();
      if (!gameId) {
        alert("Enter a Game ID.");
        return;
      }

      const { firstName,lastName } = getName();
      const displayName = (firstName + " " + lastName).trim();
      const playerId = makePlayerId(firstName,lastName);
      currentPlayerId = playerId;
      currentPlayerName = displayName;
      currentGameId = gameId;

      const gref = doc(db,"games",gameId);
      const gSnap = await getDoc(gref);
      if (!gSnap.exists()) {
        alert("Game not found: " + gameId);
        return;
      }

      const pref = doc(db,"games",gameId,"players",playerId);
      await setDoc(pref,{
        firstName,lastName,displayName,
        isAdmin:false,
        joinedAt:serverTimestamp()
      },{merge:true});

      $("stateGameId").textContent = gameId;
      $("currentConnection").textContent = "Connected to game " + gameId;

      log("Joined game " + gameId + " as " + displayName + ".");

      subscribeGame(gameId);
      subscribePlayers(gameId);
      subscribeHostChat(gameId);
    }

    /************ Subscriptions ************/
    function subscribeGame(gameId) {
      if (unsubGame) { unsubGame(); unsubGame=null; }
      const gref = doc(db,"games",gameId);
      unsubGame = onSnapshot(gref,(snap)=>{
        if (!snap.exists()) return;
        const d = snap.data();

        const status = d.status || "lobby";
        const roundsMode = d.roundsMode || "3";
        const currentRound = d.currentRound || 0;
        const totalR = d.totalRounds || 0;

        currentRoundsMode = roundsMode;
        currentRoundNumber = currentRound;
        totalRounds = totalR;
        currentIsAdmin = (d.adminPlayerId === currentPlayerId);

        $("stateStatus").textContent = status;
        $("stateMode").textContent = (roundsMode === "all" ? "All questions" : roundsMode + " rounds");
        $("stateRound").textContent = totalR ? (currentRound + " / " + totalR) : "–";
        $("stateAdmin").textContent = d.adminDisplayName || d.adminPlayerId || "–";

        const idx = d.currentQuestionIndex || 0;
        const questions = d.questions || [];
        const q = questions[idx] || null;

        if (status === "in_progress" && currentRound > 0 && q) {
          $("stateVerseRef").textContent = q.verseRef || q.VerseRef || "";
          $("stateVerseText").textContent = q.verseText || q.VerseText || "";
          $("stateQuestion").textContent = q.question || q.Question || "";
          $("hostRoundFeedback").textContent = "Game in progress.";
          startTimerVisual();
        } else {
          $("stateVerseRef").textContent = "Waiting for game to start…";
          $("stateVerseText").textContent = "Verse and question will appear when the round starts.";
          $("stateQuestion").textContent = "";
          $("hostRoundFeedback").textContent = (status === "finished")
            ? "Game finished."
            : "Waiting for host to start game.";
          $("answerCardsHost").innerHTML = '<div class="small">Waiting for round cards…</div>';
          $("stateTimer").textContent = "–";
          stopTimerVisual();
        }

        lastGameStatus = status;
      });
    }

    function subscribePlayers(gameId) {
      if (unsubPlayers) { unsubPlayers(); unsubPlayers=null; }
      const col = collection(db,"games",gameId,"players");
      unsubPlayers = onSnapshot(col,(snap)=>{
        latestPlayers = [];
        const voteCounts = {}; // for admin votes summary (optional)
        snap.forEach(docSnap=>{
          const d = docSnap.data();
          const id = docSnap.id;
          const name = (d.displayName || (d.firstName + " " + d.lastName) || "Player").trim();
          latestPlayers.push({
            id,
            name,
            score: typeof d.score==="number" ? d.score : 0,
            isAdmin: !!d.isAdmin,
            adminVoteFor: d.adminVoteFor || null
          });
          if (d.adminVoteFor) {
            voteCounts[d.adminVoteFor] = (voteCounts[d.adminVoteFor] || 0) + 1;
          }
        });

        renderPlayersPanelHost();
        renderAdminVoteSelect();
        renderAdminVotesSummary(voteCounts);
      });
    }

    function subscribeHostChat(gameId) {
      if (unsubHostChat) { unsubHostChat(); unsubHostChat=null; }
      const col = collection(db,"games",gameId,"messages");
      const qChat = query(col, orderBy("createdAt","desc"), limit(30));
      const el = $("hostChatList");
      unsubHostChat = onSnapshot(qChat,(snap)=>{
        let html = "";
        snap.forEach(docSnap=>{
          const d = docSnap.data();
          const name = d.fromName || "Player";
          const text = d.text || "";
          html = `<div><strong>${name}:</strong> ${text}</div>` + html;
        });
        el.innerHTML = html || '<div class="small">No messages yet.</div>';
      });
    }

    // show a few most recent non-deleted rooms for convenience
    function subscribeRoomsHost() {
      if (unsubRoomsHost) { unsubRoomsHost(); unsubRoomsHost=null; }
      const gamesCol = collection(db,"games");
      const qRooms = query(gamesCol, orderBy("createdAt","desc"), limit(15));
      const listEl = $("roomsHostList");
      unsubRoomsHost = onSnapshot(qRooms,(snap)=>{
        if (snap.empty) {
          listEl.innerHTML = '<div class="small">No games yet.</div>';
          return;
        }
        let html = "";
        snap.forEach(docSnap=>{
          const d = docSnap.data();
          if (d.isDeleted) return;
          const id = docSnap.id;
          const status = d.status || "lobby";
          const roundsMode = d.roundsMode || "3";
          const adminName = d.adminDisplayName || "Unknown";
          const labelStatus =
            status === "in_progress" ? "In progress" :
            status === "finished" ? "Finished" : "Lobby";

          html += `
            <div class="roomListHostItem">
              <div class="roomListHostItemTitle">${adminName}'s room</div>
              <div>ID: <span class="mono">${id}</span></div>
              <div>Status: ${labelStatus} • Mode: ${roundsMode}</div>
            </div>`;
        });
        listEl.innerHTML = html || '<div class="small">No active rooms.</div>';
      });
    }

    /************ Players panel + admin voting ************/
    function renderPlayersPanelHost() {
      const panel = $("playersPanelHost");
      if (!panel) return;
      panel.innerHTML = "";

      if (!latestPlayers.length) {
        panel.innerHTML = '<div class="small">No players yet.</div>';
        return;
      }

      const sorted = [...latestPlayers].sort((a,b)=>b.score - a.score);

      sorted.forEach(p=>{
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.alignItems = "center";
        row.style.justifyContent = "space-between";
        row.style.fontSize = "0.8rem";
        row.style.marginBottom = "0.2rem";

        const left = document.createElement("div");
        const youMark = p.id === currentPlayerId ? " (you)" : "";
        const adminMark = p.isAdmin ? " ★" : "";
        left.textContent = `${p.name} – ${p.score || 0} pts${youMark}${adminMark}`;
        row.appendChild(left);

        // Kick button (admin only, can't kick admin)
        if (currentIsAdmin && !p.isAdmin) {
          const btn = document.createElement("button");
          btn.textContent = "Kick";
          btn.className = "secondary";
          btn.style.fontSize = "0.7rem";
          btn.onclick = () => kickPlayer(p.id);
          row.appendChild(btn);
        }

        panel.appendChild(row);
      });
    }

    function renderAdminVoteSelect() {
      const sel = $("adminVoteSelect");
      sel.innerHTML = '<option value="">-- choose player --</option>';
      latestPlayers.forEach(p=>{
        const opt = document.createElement("option");
        opt.value = p.id;
        opt.textContent = p.name + (p.id===currentPlayerId ? " (you)" : "");
        sel.appendChild(opt);
      });
    }

    function renderAdminVotesSummary(voteCounts) {
      const span = $("adminVotesSummary");
      if (!voteCounts || Object.keys(voteCounts).length === 0) {
        span.textContent = "no votes yet";
        return;
      }
      const parts = [];
      for (const pid in voteCounts) {
        const player = latestPlayers.find(p => p.id === pid);
        const name = player ? player.name : pid;
        parts.push(`${name}: ${voteCounts[pid]} vote(s)`);
      }
      span.textContent = parts.join(", ");
    }

    async function submitAdminVote() {
      if (!currentGameId || !currentPlayerId) return;
      const targetId = $("adminVoteSelect").value;
      const pref = doc(db,"games",currentGameId,"players",currentPlayerId);
      await setDoc(pref,{ adminVoteFor: targetId || null },{ merge:true });
    }

    async function applyAdminByVotes() {
      if (!currentGameId || !currentPlayerId) return;
      if (!currentIsAdmin) {
        alert("Only the current admin can apply votes.");
        return;
      }
      if (!latestPlayers.length) return;

      const counts = {};
      latestPlayers.forEach(p=>{
        if (p.adminVoteFor) {
          counts[p.adminVoteFor] = (counts[p.adminVoteFor] || 0) + 1;
        }
      });
      if (Object.keys(counts).length === 0) {
        alert("No votes yet.");
        return;
      }
      let bestId = null;
      let bestCount = -1;
      for (const pid in counts) {
        if (counts[pid] > bestCount) {
          bestId = pid;
          bestCount = counts[pid];
        }
      }
      const winner = latestPlayers.find(p=>p.id===bestId);
      if (!winner) return;

      const ok = confirm(`Change admin to ${winner.name} (${bestCount} vote(s))?`);
      if (!ok) return;

      const gref = doc(db,"games",currentGameId);
      await setDoc(gref,{
        adminPlayerId: winner.id,
        adminDisplayName: winner.name
      }, { merge:true });

      await setDoc(doc(db,"games",currentGameId,"players",winner.id),{
        isAdmin:true
      },{merge:true});
      await setDoc(doc(db,"games",currentGameId,"players",currentPlayerId),{
        isAdmin:false
      },{merge:true:true});

      log("Admin changed to " + winner.name + " by votes.");
    }

    /************ Kick player (admin only) ************/
    async function kickPlayer(playerId) {
      if (!currentGameId || !currentPlayerId) return;
      if (!currentIsAdmin) {
        alert("Only the admin can kick players.");
        return;
      }
      if (playerId === currentPlayerId) {
        alert("You can’t kick yourself.");
        return;
      }
      const player = latestPlayers.find(p=>p.id===playerId);
      const name = player ? player.name : playerId;
      const ok = confirm(`Kick ${name} from this room?`);
      if (!ok) return;

      const pref = doc(db,"games",currentGameId,"players",playerId);
      await deleteDoc(pref);
      log("Kicked player " + name);
    }

    /************ Round handling (simplified) ************/
    async function startGame() {
      if (!currentGameId) {
        alert("Create or join a game first.");
        return;
      }
      if (!currentIsAdmin) {
        alert("Only admin can start the game.");
        return;
      }
      if (!questionsCache.length) {
        // load from game doc if needed
        const gref = doc(db,"games",currentGameId);
        const snap = await getDoc(gref);
        if (snap.exists()) {
          questionsCache = snap.data().questions || [];
        }
      }
      if (!questionsCache.length) {
        alert("No questions loaded.");
        return;
      }

      const roundsMode = $("roundsModeSelect").value || "3";
      currentRoundsMode = roundsMode;
      totalRounds = (roundsMode === "all") ? questionsCache.length : Number(roundsMode);

      const gref = doc(db,"games",currentGameId);
      await setDoc(gref,{
        status:"in_progress",
        currentRound:1,
        totalRounds,
        roundsMode
      },{merge:true});

      await generateCardsForRound(1);
      log("Game started with " + totalRounds + " rounds.");
    }

    async function nextRound() {
      if (!currentGameId) return;
      if (!currentIsAdmin) {
        alert("Only admin can change rounds.");
        return;
      }
      if (!totalRounds) {
        alert("Game not started yet.");
        return;
      }
      const next = currentRoundNumber + 1;
      if (next > totalRounds) {
        alert("No more rounds. End the game.");
        return;
      }

      const gref = doc(db,"games",currentGameId);
      await setDoc(gref,{ currentRound: next },{merge:true});
      await generateCardsForRound(next);
      log("Showing question #" + next);
    }

    async function endGame() {
      if (!currentGameId) return;
      if (!currentIsAdmin) {
        alert("Only admin can end the game.");
        return;
      }
      const gref = doc(db,"games",currentGameId);
      await setDoc(gref,{ status:"finished" },{merge:true});
      stopTimerVisual();
      $("stateTimer").textContent = "–";
      log("Game finished.");
    }

    async function deleteGame() {
      if (!currentGameId) return;
      if (!currentIsAdmin) {
        alert("Only admin can delete game (mark as deleted).");
        return;
      }
      const ok = confirm("Mark this room as deleted and hide it from the lobby?");
      if (!ok) return;

      const gref = doc(db,"games",currentGameId);
      await setDoc(gref,{ isDeleted:true },{merge:true});
      log("Game marked as deleted.");
    }

    async function generateCardsForRound(roundNumber) {
      if (!currentGameId) return;
      if (!questionsCache.length) {
        const gref = doc(db,"games",currentGameId);
        const snap = await getDoc(gref);
        if (snap.exists()) {
          questionsCache = snap.data().questions || [];
        }
      }
      if (!questionsCache.length) return;

      const qIndex = (roundNumber - 1) % questionsCache.length;
      const q = questionsCache[qIndex];

      const gref = doc(db,"games",currentGameId);
      await setDoc(gref,{
        currentQuestionIndex: qIndex,
        currentRound: roundNumber,
        status:"in_progress"
      },{merge:true});

      const playersCol = collection(db,"games",currentGameId,"players");
      const snapPlayers = await getDocs(playersCol);
      const roundRef = doc(db,"games",currentGameId,"rounds",String(roundNumber));
      await setDoc(roundRef,{
        questionIndex: qIndex,
        createdAt: serverTimestamp()
      },{merge:true});

      const cardsHost = $("answerCardsHost");
      cardsHost.innerHTML = "";
      let hostCards = [];

      for (const playerDoc of snapPlayers.docs) {
        const pid = playerDoc.id;
        const cardsInfo = buildCardsForPlayer(q);
        const psRef = doc(db,"games",currentGameId,"rounds",String(roundNumber),"playerStates",pid);
        await setDoc(psRef,{
          cards: cardsInfo.cards,
          correctIndex: cardsInfo.correctIndex,
          hasAnswered:false,
          isCorrect:false,
          wrongCount:0
        },{merge:true});

        if (pid === currentPlayerId) hostCards = cardsInfo.cards;
      }

      if (hostCards.length) {
        hostCards.forEach(text=>{
          const b = document.createElement("button");
          b.textContent = text;
          cardsHost.appendChild(b);
        });
      } else {
        cardsHost.innerHTML = '<div class="small">Cards generated. View in play.html as a normal player.</div>';
      }

      startTimerVisual();
      blinkTimer();
    }

    /************ UI wiring ************/
    document.addEventListener("DOMContentLoaded", () => {
      // prefill Sheets URL from localStorage or default
      const input = $("sheetsApiUrl");
      if (input) {
        const saved = localStorage.getItem("sheetsApiUrl");
        input.value = saved || DEFAULT_SHEETS_API_URL;
      }

      $("createGameBtn").onclick = async () => {
        try {
          await createGame();
        } catch (e) {
          console.error(e);
          alert(e.message || "Error creating game.");
          log("Error: " + e.message);
        }
      };

      $("joinGameBtn").onclick = async () => {
        try {
          await joinGame();
        } catch (e) {
          console.error(e);
          alert(e.message || "Error joining game.");
          log("Error: " + e.message);
        }
      };

      $("submitVoteBtn").onclick = submitAdminVote;
      $("applyAdminVotesBtn").onclick = applyAdminByVotes;
      $("startGameBtn").onclick = startGame;
      $("nextRoundBtn").onclick = nextRound;
      $("endGameBtn").onclick = endGame;
      $("deleteGameBtn").onclick = deleteGame;

      subscribeRoomsHost();
      log("Host UI ready.");
    });
  </script>
</body>
</html>
